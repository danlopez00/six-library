# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_math_linear')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_math_linear')
    _math_linear = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_math_linear', [dirname(__file__)])
        except ImportError:
            import _math_linear
            return _math_linear
        if fp is not None:
            try:
                _mod = imp.load_module('_math_linear', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _math_linear = swig_import_helper()
    del swig_import_helper
else:
    import _math_linear
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

import coda.coda_except
class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _math_linear.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        """value(SwigPyIterator self) -> PyObject *"""
        return _math_linear.SwigPyIterator_value(self)


    def incr(self, n=1):
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _math_linear.SwigPyIterator_incr(self, n)


    def decr(self, n=1):
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _math_linear.SwigPyIterator_decr(self, n)


    def distance(self, x):
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _math_linear.SwigPyIterator_distance(self, x)


    def equal(self, x):
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _math_linear.SwigPyIterator_equal(self, x)


    def copy(self):
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _math_linear.SwigPyIterator_copy(self)


    def next(self):
        """next(SwigPyIterator self) -> PyObject *"""
        return _math_linear.SwigPyIterator_next(self)


    def __next__(self):
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _math_linear.SwigPyIterator___next__(self)


    def previous(self):
        """previous(SwigPyIterator self) -> PyObject *"""
        return _math_linear.SwigPyIterator_previous(self)


    def advance(self, n):
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _math_linear.SwigPyIterator_advance(self, n)


    def __eq__(self, x):
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _math_linear.SwigPyIterator___eq__(self, x)


    def __ne__(self, x):
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _math_linear.SwigPyIterator___ne__(self, x)


    def __iadd__(self, n):
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _math_linear.SwigPyIterator___iadd__(self, n)


    def __isub__(self, n):
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _math_linear.SwigPyIterator___isub__(self, n)


    def __add__(self, n):
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _math_linear.SwigPyIterator___add__(self, n)


    def __sub__(self, *args):
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _math_linear.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self
SwigPyIterator_swigregister = _math_linear.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


import sys
if sys.version_info[0] == 2:
    import cPickle as pickle
else:
    import pickle

import coda.coda_types
import coda.coda_sys
class std_vector_double(_object):
    """Proxy of C++ std::vector<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, std_vector_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, std_vector_double, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(std_vector_double self) -> SwigPyIterator"""
        return _math_linear.std_vector_double_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(std_vector_double self) -> bool"""
        return _math_linear.std_vector_double___nonzero__(self)


    def __bool__(self):
        """__bool__(std_vector_double self) -> bool"""
        return _math_linear.std_vector_double___bool__(self)


    def __len__(self):
        """__len__(std_vector_double self) -> std::vector< double >::size_type"""
        return _math_linear.std_vector_double___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(std_vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> std_vector_double"""
        return _math_linear.std_vector_double___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(std_vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(std_vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, std_vector_double v)
        """
        return _math_linear.std_vector_double___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(std_vector_double self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _math_linear.std_vector_double___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(std_vector_double self, std::vector< double >::difference_type i)
        __delitem__(std_vector_double self, PySliceObject * slice)
        """
        return _math_linear.std_vector_double___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(std_vector_double self, PySliceObject * slice) -> std_vector_double
        __getitem__(std_vector_double self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _math_linear.std_vector_double___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(std_vector_double self, PySliceObject * slice, std_vector_double v)
        __setitem__(std_vector_double self, PySliceObject * slice)
        __setitem__(std_vector_double self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _math_linear.std_vector_double___setitem__(self, *args)


    def pop(self):
        """pop(std_vector_double self) -> std::vector< double >::value_type"""
        return _math_linear.std_vector_double_pop(self)


    def append(self, x):
        """append(std_vector_double self, std::vector< double >::value_type const & x)"""
        return _math_linear.std_vector_double_append(self, x)


    def empty(self):
        """empty(std_vector_double self) -> bool"""
        return _math_linear.std_vector_double_empty(self)


    def size(self):
        """size(std_vector_double self) -> std::vector< double >::size_type"""
        return _math_linear.std_vector_double_size(self)


    def swap(self, v):
        """swap(std_vector_double self, std_vector_double v)"""
        return _math_linear.std_vector_double_swap(self, v)


    def begin(self):
        """begin(std_vector_double self) -> std::vector< double >::iterator"""
        return _math_linear.std_vector_double_begin(self)


    def end(self):
        """end(std_vector_double self) -> std::vector< double >::iterator"""
        return _math_linear.std_vector_double_end(self)


    def rbegin(self):
        """rbegin(std_vector_double self) -> std::vector< double >::reverse_iterator"""
        return _math_linear.std_vector_double_rbegin(self)


    def rend(self):
        """rend(std_vector_double self) -> std::vector< double >::reverse_iterator"""
        return _math_linear.std_vector_double_rend(self)


    def clear(self):
        """clear(std_vector_double self)"""
        return _math_linear.std_vector_double_clear(self)


    def get_allocator(self):
        """get_allocator(std_vector_double self) -> std::vector< double >::allocator_type"""
        return _math_linear.std_vector_double_get_allocator(self)


    def pop_back(self):
        """pop_back(std_vector_double self)"""
        return _math_linear.std_vector_double_pop_back(self)


    def erase(self, *args):
        """
        erase(std_vector_double self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(std_vector_double self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _math_linear.std_vector_double_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(double)> self) -> std_vector_double
        __init__(std::vector<(double)> self, std_vector_double arg2) -> std_vector_double
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> std_vector_double
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> std_vector_double
        """
        this = _math_linear.new_std_vector_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(std_vector_double self, std::vector< double >::value_type const & x)"""
        return _math_linear.std_vector_double_push_back(self, x)


    def front(self):
        """front(std_vector_double self) -> std::vector< double >::value_type const &"""
        return _math_linear.std_vector_double_front(self)


    def back(self):
        """back(std_vector_double self) -> std::vector< double >::value_type const &"""
        return _math_linear.std_vector_double_back(self)


    def assign(self, n, x):
        """assign(std_vector_double self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _math_linear.std_vector_double_assign(self, n, x)


    def resize(self, *args):
        """
        resize(std_vector_double self, std::vector< double >::size_type new_size)
        resize(std_vector_double self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _math_linear.std_vector_double_resize(self, *args)


    def insert(self, *args):
        """
        insert(std_vector_double self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(std_vector_double self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _math_linear.std_vector_double_insert(self, *args)


    def reserve(self, n):
        """reserve(std_vector_double self, std::vector< double >::size_type n)"""
        return _math_linear.std_vector_double_reserve(self, n)


    def capacity(self):
        """capacity(std_vector_double self) -> std::vector< double >::size_type"""
        return _math_linear.std_vector_double_capacity(self)


    def __getstate__(self):
    # Return a nonempty (thus non-false) tuple with dummy value in first position
        return (-1, tuple(pickle.dumps(elem) for elem in self))

    def __setstate__(self, state):
        self.__init__()
    # State will have a dummy entry in the first position
        for elem in state[1]:
            self.push_back(pickle.loads(elem))

    __swig_destroy__ = _math_linear.delete_std_vector_double
    __del__ = lambda self: None
std_vector_double_swigregister = _math_linear.std_vector_double_swigregister
std_vector_double_swigregister(std_vector_double)

class std_vector_vector_double(_object):
    """Proxy of C++ std::vector<(std::vector<(double)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, std_vector_vector_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, std_vector_vector_double, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(std_vector_vector_double self) -> SwigPyIterator"""
        return _math_linear.std_vector_vector_double_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(std_vector_vector_double self) -> bool"""
        return _math_linear.std_vector_vector_double___nonzero__(self)


    def __bool__(self):
        """__bool__(std_vector_vector_double self) -> bool"""
        return _math_linear.std_vector_vector_double___bool__(self)


    def __len__(self):
        """__len__(std_vector_vector_double self) -> std::vector< std::vector< double > >::size_type"""
        return _math_linear.std_vector_vector_double___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(std_vector_vector_double self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j) -> std_vector_vector_double"""
        return _math_linear.std_vector_vector_double___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(std_vector_vector_double self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)
        __setslice__(std_vector_vector_double self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j, std_vector_vector_double v)
        """
        return _math_linear.std_vector_vector_double___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(std_vector_vector_double self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)"""
        return _math_linear.std_vector_vector_double___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(std_vector_vector_double self, std::vector< std::vector< double > >::difference_type i)
        __delitem__(std_vector_vector_double self, PySliceObject * slice)
        """
        return _math_linear.std_vector_vector_double___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(std_vector_vector_double self, PySliceObject * slice) -> std_vector_vector_double
        __getitem__(std_vector_vector_double self, std::vector< std::vector< double > >::difference_type i) -> std_vector_double
        """
        return _math_linear.std_vector_vector_double___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(std_vector_vector_double self, PySliceObject * slice, std_vector_vector_double v)
        __setitem__(std_vector_vector_double self, PySliceObject * slice)
        __setitem__(std_vector_vector_double self, std::vector< std::vector< double > >::difference_type i, std_vector_double x)
        """
        return _math_linear.std_vector_vector_double___setitem__(self, *args)


    def pop(self):
        """pop(std_vector_vector_double self) -> std_vector_double"""
        return _math_linear.std_vector_vector_double_pop(self)


    def append(self, x):
        """append(std_vector_vector_double self, std_vector_double x)"""
        return _math_linear.std_vector_vector_double_append(self, x)


    def empty(self):
        """empty(std_vector_vector_double self) -> bool"""
        return _math_linear.std_vector_vector_double_empty(self)


    def size(self):
        """size(std_vector_vector_double self) -> std::vector< std::vector< double > >::size_type"""
        return _math_linear.std_vector_vector_double_size(self)


    def swap(self, v):
        """swap(std_vector_vector_double self, std_vector_vector_double v)"""
        return _math_linear.std_vector_vector_double_swap(self, v)


    def begin(self):
        """begin(std_vector_vector_double self) -> std::vector< std::vector< double > >::iterator"""
        return _math_linear.std_vector_vector_double_begin(self)


    def end(self):
        """end(std_vector_vector_double self) -> std::vector< std::vector< double > >::iterator"""
        return _math_linear.std_vector_vector_double_end(self)


    def rbegin(self):
        """rbegin(std_vector_vector_double self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _math_linear.std_vector_vector_double_rbegin(self)


    def rend(self):
        """rend(std_vector_vector_double self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _math_linear.std_vector_vector_double_rend(self)


    def clear(self):
        """clear(std_vector_vector_double self)"""
        return _math_linear.std_vector_vector_double_clear(self)


    def get_allocator(self):
        """get_allocator(std_vector_vector_double self) -> std::vector< std::vector< double > >::allocator_type"""
        return _math_linear.std_vector_vector_double_get_allocator(self)


    def pop_back(self):
        """pop_back(std_vector_vector_double self)"""
        return _math_linear.std_vector_vector_double_pop_back(self)


    def erase(self, *args):
        """
        erase(std_vector_vector_double self, std::vector< std::vector< double > >::iterator pos) -> std::vector< std::vector< double > >::iterator
        erase(std_vector_vector_double self, std::vector< std::vector< double > >::iterator first, std::vector< std::vector< double > >::iterator last) -> std::vector< std::vector< double > >::iterator
        """
        return _math_linear.std_vector_vector_double_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(double)>)> self) -> std_vector_vector_double
        __init__(std::vector<(std::vector<(double)>)> self, std_vector_vector_double arg2) -> std_vector_vector_double
        __init__(std::vector<(std::vector<(double)>)> self, std::vector< std::vector< double > >::size_type size) -> std_vector_vector_double
        __init__(std::vector<(std::vector<(double)>)> self, std::vector< std::vector< double > >::size_type size, std_vector_double value) -> std_vector_vector_double
        """
        this = _math_linear.new_std_vector_vector_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(std_vector_vector_double self, std_vector_double x)"""
        return _math_linear.std_vector_vector_double_push_back(self, x)


    def front(self):
        """front(std_vector_vector_double self) -> std_vector_double"""
        return _math_linear.std_vector_vector_double_front(self)


    def back(self):
        """back(std_vector_vector_double self) -> std_vector_double"""
        return _math_linear.std_vector_vector_double_back(self)


    def assign(self, n, x):
        """assign(std_vector_vector_double self, std::vector< std::vector< double > >::size_type n, std_vector_double x)"""
        return _math_linear.std_vector_vector_double_assign(self, n, x)


    def resize(self, *args):
        """
        resize(std_vector_vector_double self, std::vector< std::vector< double > >::size_type new_size)
        resize(std_vector_vector_double self, std::vector< std::vector< double > >::size_type new_size, std_vector_double x)
        """
        return _math_linear.std_vector_vector_double_resize(self, *args)


    def insert(self, *args):
        """
        insert(std_vector_vector_double self, std::vector< std::vector< double > >::iterator pos, std_vector_double x) -> std::vector< std::vector< double > >::iterator
        insert(std_vector_vector_double self, std::vector< std::vector< double > >::iterator pos, std::vector< std::vector< double > >::size_type n, std_vector_double x)
        """
        return _math_linear.std_vector_vector_double_insert(self, *args)


    def reserve(self, n):
        """reserve(std_vector_vector_double self, std::vector< std::vector< double > >::size_type n)"""
        return _math_linear.std_vector_vector_double_reserve(self, n)


    def capacity(self):
        """capacity(std_vector_vector_double self) -> std::vector< std::vector< double > >::size_type"""
        return _math_linear.std_vector_vector_double_capacity(self)


    def __getstate__(self):
    # Return a nonempty (thus non-false) tuple with dummy value in first position
        return (-1, tuple(pickle.dumps(elem) for elem in self))

    def __setstate__(self, state):
        self.__init__()
    # State will have a dummy entry in the first position
        for elem in state[1]:
            self.push_back(pickle.loads(elem))

    __swig_destroy__ = _math_linear.delete_std_vector_vector_double
    __del__ = lambda self: None
std_vector_vector_double_swigregister = _math_linear.std_vector_vector_double_swigregister
std_vector_vector_double_swigregister(std_vector_vector_double)

class Matrix3x1(_object):
    """Proxy of C++ math::linear::MatrixMxN<(3,1,double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix3x1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix3x1, name)
    __repr__ = _swig_repr
    __swig_setmethods__["mRaw"] = _math_linear.Matrix3x1_mRaw_set
    __swig_getmethods__["mRaw"] = _math_linear.Matrix3x1_mRaw_get
    if _newclass:
        mRaw = _swig_property(_math_linear.Matrix3x1_mRaw_get, _math_linear.Matrix3x1_mRaw_set)

    def __init__(self, *args):
        """
        __init__(math::linear::MatrixMxN<(3,1,double)> self) -> Matrix3x1
        __init__(math::linear::MatrixMxN<(3,1,double)> self, double cv) -> Matrix3x1
        __init__(math::linear::MatrixMxN<(3,1,double)> self, double const * raw) -> Matrix3x1
        __init__(math::linear::MatrixMxN<(3,1,double)> self, std_vector_double raw) -> Matrix3x1
        __init__(math::linear::MatrixMxN<(3,1,double)> self, Matrix3x1 mx) -> Matrix3x1
        """
        this = _math_linear.new_Matrix3x1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _math_linear.delete_Matrix3x1
    __del__ = lambda self: None

    def __call__(self, *args):
        """
        __call__(Matrix3x1 self, size_t i, size_t j) -> double
        __call__(Matrix3x1 self, size_t i, size_t j) -> double &
        """
        return _math_linear.Matrix3x1___call__(self, *args)


    def row(self, *args):
        """
        row(Matrix3x1 self, size_t i) -> double const
        row(Matrix3x1 self, size_t i) -> double
        row(Matrix3x1 self, size_t i, double const * vec)
        row(Matrix3x1 self, size_t i, std_vector_double vec)
        """
        return _math_linear.Matrix3x1_row(self, *args)


    def col(self, *args):
        """
        col(Matrix3x1 self, size_t j) -> std_vector_double
        col(Matrix3x1 self, size_t j, double const * vec)
        col(Matrix3x1 self, size_t j, std_vector_double vec)
        col(Matrix3x1 self, size_t colIdx, Matrix3x1 vec)
        """
        return _math_linear.Matrix3x1_col(self, *args)


    def rows(self):
        """rows(Matrix3x1 self) -> size_t"""
        return _math_linear.Matrix3x1_rows(self)


    def cols(self):
        """cols(Matrix3x1 self) -> size_t"""
        return _math_linear.Matrix3x1_cols(self)


    def size(self):
        """size(Matrix3x1 self) -> size_t"""
        return _math_linear.Matrix3x1_size(self)


    def scale(self, scalar):
        """scale(Matrix3x1 self, double scalar) -> Matrix3x1"""
        return _math_linear.Matrix3x1_scale(self, scalar)


    def multiply(self, scalar):
        """multiply(Matrix3x1 self, double scalar) -> Matrix3x1"""
        return _math_linear.Matrix3x1_multiply(self, scalar)


    def scaleDiagonal(self, mx):
        """scaleDiagonal(Matrix3x1 self, math::linear::MatrixMxN< 1,1,double > const & mx) -> Matrix3x1"""
        return _math_linear.Matrix3x1_scaleDiagonal(self, mx)


    def multiplyDiagonal(self, mx):
        """multiplyDiagonal(Matrix3x1 self, math::linear::MatrixMxN< 1,1,double > const & mx) -> Matrix3x1"""
        return _math_linear.Matrix3x1_multiplyDiagonal(self, mx)


    def __iadd__(self, mx):
        """__iadd__(Matrix3x1 self, Matrix3x1 mx) -> Matrix3x1"""
        return _math_linear.Matrix3x1___iadd__(self, mx)


    def __isub__(self, mx):
        """__isub__(Matrix3x1 self, Matrix3x1 mx) -> Matrix3x1"""
        return _math_linear.Matrix3x1___isub__(self, mx)


    def add(self, mx):
        """add(Matrix3x1 self, Matrix3x1 mx) -> Matrix3x1"""
        return _math_linear.Matrix3x1_add(self, mx)


    def subtract(self, mx):
        """subtract(Matrix3x1 self, Matrix3x1 mx) -> Matrix3x1"""
        return _math_linear.Matrix3x1_subtract(self, mx)


    def transpose(self):
        """transpose(Matrix3x1 self) -> math::linear::MatrixMxN< 1,3,double >"""
        return _math_linear.Matrix3x1_transpose(self)


    def decomposeLU(self, pivotsM):
        """decomposeLU(Matrix3x1 self, VectorSizeT pivotsM) -> Matrix3x1"""
        return _math_linear.Matrix3x1_decomposeLU(self, pivotsM)


    def permute(self, pivotsM, n=1):
        """
        permute(Matrix3x1 self, VectorSizeT pivotsM, size_t n=1) -> Matrix3x1
        permute(Matrix3x1 self, VectorSizeT pivotsM) -> Matrix3x1
        """
        return _math_linear.Matrix3x1_permute(self, pivotsM, n)


    def normSq(self):
        """normSq(Matrix3x1 self) -> double"""
        return _math_linear.Matrix3x1_normSq(self)


    def norm(self):
        """norm(Matrix3x1 self) -> double"""
        return _math_linear.Matrix3x1_norm(self)


    def normalize(self):
        """normalize(Matrix3x1 self) -> Matrix3x1"""
        return _math_linear.Matrix3x1_normalize(self)


    def unit(self):
        """unit(Matrix3x1 self) -> Matrix3x1"""
        return _math_linear.Matrix3x1_unit(self)


    def __add__(self, mx):
        """__add__(Matrix3x1 self, Matrix3x1 mx) -> Matrix3x1"""
        return _math_linear.Matrix3x1___add__(self, mx)


    def __sub__(self, mx):
        """__sub__(Matrix3x1 self, Matrix3x1 mx) -> Matrix3x1"""
        return _math_linear.Matrix3x1___sub__(self, mx)


    def __mul__(self, scalar):
        """__mul__(Matrix3x1 self, double scalar) -> Matrix3x1"""
        return _math_linear.Matrix3x1___mul__(self, scalar)


    def __div__(self, scalar):
        """__div__(Matrix3x1 self, double scalar) -> Matrix3x1"""
        return _math_linear.Matrix3x1___div__(self, scalar)


    def __neg__(self):
        """__neg__(Matrix3x1 self) -> Matrix3x1"""
        return _math_linear.Matrix3x1___neg__(self)

Matrix3x1_swigregister = _math_linear.Matrix3x1_swigregister
Matrix3x1_swigregister(Matrix3x1)

class Vector2(_object):
    """Proxy of C++ math::linear::VectorN<(2,double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector2, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math::linear::VectorN<(2,double)> self) -> Vector2
        __init__(math::linear::VectorN<(2,double)> self, double sv) -> Vector2
        __init__(math::linear::VectorN<(2,double)> self, double const * raw) -> Vector2
        __init__(math::linear::VectorN<(2,double)> self, Vector2 v) -> Vector2
        __init__(math::linear::VectorN<(2,double)> self, math::linear::MatrixMxN< 2,1,double > const & mx) -> Vector2
        __init__(math::linear::VectorN<(2,double)> self, std_vector_double raw) -> Vector2
        """
        this = _math_linear.new_Vector2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _math_linear.delete_Vector2
    __del__ = lambda self: None

    def matrix(self, *args):
        """
        matrix(Vector2 self) -> math::linear::MatrixMxN< 2,1,double >
        matrix(Vector2 self) -> math::linear::MatrixMxN< 2,1,double > const &
        """
        return _math_linear.Vector2_matrix(self, *args)


    def size(self):
        """size(Vector2 self) -> size_t"""
        return _math_linear.Vector2_size(self)


    def dot(self, vec):
        """dot(Vector2 self, Vector2 vec) -> double"""
        return _math_linear.Vector2_dot(self, vec)


    def normDot(self, vec):
        """normDot(Vector2 self, Vector2 vec) -> double"""
        return _math_linear.Vector2_normDot(self, vec)


    def norm(self):
        """norm(Vector2 self) -> double"""
        return _math_linear.Vector2_norm(self)


    def normSq(self):
        """normSq(Vector2 self) -> double"""
        return _math_linear.Vector2_normSq(self)


    def angle(self, v):
        """angle(Vector2 self, Vector2 v) -> double"""
        return _math_linear.Vector2_angle(self, v)


    def normalize(self):
        """normalize(Vector2 self)"""
        return _math_linear.Vector2_normalize(self)


    def unit(self):
        """unit(Vector2 self) -> Vector2"""
        return _math_linear.Vector2_unit(self)


    def scale(self, scalar):
        """scale(Vector2 self, double scalar)"""
        return _math_linear.Vector2_scale(self, scalar)


    def __iadd__(self, v):
        """__iadd__(Vector2 self, Vector2 v) -> Vector2"""
        return _math_linear.Vector2___iadd__(self, v)


    def __isub__(self, v):
        """__isub__(Vector2 self, Vector2 v) -> Vector2"""
        return _math_linear.Vector2___isub__(self, v)


    def add(self, v):
        """add(Vector2 self, Vector2 v) -> Vector2"""
        return _math_linear.Vector2_add(self, v)


    def subtract(self, v):
        """subtract(Vector2 self, Vector2 v) -> Vector2"""
        return _math_linear.Vector2_subtract(self, v)


    def __add__(self, v):
        """__add__(Vector2 self, Vector2 v) -> Vector2"""
        return _math_linear.Vector2___add__(self, v)


    def __sub__(self, v):
        """__sub__(Vector2 self, Vector2 v) -> Vector2"""
        return _math_linear.Vector2___sub__(self, v)


    def __neg__(self):
        """__neg__(Vector2 self) -> Vector2"""
        return _math_linear.Vector2___neg__(self)


    def __imul__(self, *args):
        """
        __imul__(Vector2 self, Vector2 v) -> Vector2
        __imul__(Vector2 self, double sv) -> Vector2
        """
        return _math_linear.Vector2___imul__(self, *args)


    def __idiv__(self, v):
        """__idiv__(Vector2 self, Vector2 v) -> Vector2"""
        return _math_linear.Vector2___idiv__(self, v)


    def __mul__(self, *args):
        """
        __mul__(Vector2 self, double sv) -> Vector2
        __mul__(Vector2 self, Vector2 v) -> Vector2
        """
        return _math_linear.Vector2___mul__(self, *args)


    def __div__(self, v):
        """__div__(Vector2 self, Vector2 v) -> Vector2"""
        return _math_linear.Vector2___div__(self, v)


    def __getstate__(self):
        return pickle.dumps(self.vals())
    def __setstate__(self, state):
        self.__init__(pickle.loads(state))


    def __getitem__(self, i):
        """__getitem__(Vector2 self, long i) -> double"""
        return _math_linear.Vector2___getitem__(self, i)


    def __setitem__(self, i, val):
        """__setitem__(Vector2 self, long i, double val)"""
        return _math_linear.Vector2___setitem__(self, i, val)


    def __str__(self):
        """__str__(Vector2 self) -> std::string"""
        return _math_linear.Vector2___str__(self)


    def __deepcopy__(self, memo):
        """__deepcopy__(Vector2 self, PyObject * memo) -> Vector2"""
        return _math_linear.Vector2___deepcopy__(self, memo)


    def vals(self):
        """vals(Vector2 self) -> std_vector_double"""
        return _math_linear.Vector2_vals(self)

Vector2_swigregister = _math_linear.Vector2_swigregister
Vector2_swigregister(Vector2)

class Vector3(_object):
    """Proxy of C++ math::linear::VectorN<(3,double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector3, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math::linear::VectorN<(3,double)> self) -> Vector3
        __init__(math::linear::VectorN<(3,double)> self, double sv) -> Vector3
        __init__(math::linear::VectorN<(3,double)> self, double const * raw) -> Vector3
        __init__(math::linear::VectorN<(3,double)> self, Vector3 v) -> Vector3
        __init__(math::linear::VectorN<(3,double)> self, Matrix3x1 mx) -> Vector3
        __init__(math::linear::VectorN<(3,double)> self, std_vector_double raw) -> Vector3
        """
        this = _math_linear.new_Vector3(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _math_linear.delete_Vector3
    __del__ = lambda self: None

    def matrix(self, *args):
        """
        matrix(Vector3 self) -> Matrix3x1
        matrix(Vector3 self) -> Matrix3x1
        """
        return _math_linear.Vector3_matrix(self, *args)


    def size(self):
        """size(Vector3 self) -> size_t"""
        return _math_linear.Vector3_size(self)


    def dot(self, vec):
        """dot(Vector3 self, Vector3 vec) -> double"""
        return _math_linear.Vector3_dot(self, vec)


    def normDot(self, vec):
        """normDot(Vector3 self, Vector3 vec) -> double"""
        return _math_linear.Vector3_normDot(self, vec)


    def norm(self):
        """norm(Vector3 self) -> double"""
        return _math_linear.Vector3_norm(self)


    def normSq(self):
        """normSq(Vector3 self) -> double"""
        return _math_linear.Vector3_normSq(self)


    def angle(self, v):
        """angle(Vector3 self, Vector3 v) -> double"""
        return _math_linear.Vector3_angle(self, v)


    def normalize(self):
        """normalize(Vector3 self)"""
        return _math_linear.Vector3_normalize(self)


    def unit(self):
        """unit(Vector3 self) -> Vector3"""
        return _math_linear.Vector3_unit(self)


    def scale(self, scalar):
        """scale(Vector3 self, double scalar)"""
        return _math_linear.Vector3_scale(self, scalar)


    def __iadd__(self, v):
        """__iadd__(Vector3 self, Vector3 v) -> Vector3"""
        return _math_linear.Vector3___iadd__(self, v)


    def __isub__(self, v):
        """__isub__(Vector3 self, Vector3 v) -> Vector3"""
        return _math_linear.Vector3___isub__(self, v)


    def add(self, v):
        """add(Vector3 self, Vector3 v) -> Vector3"""
        return _math_linear.Vector3_add(self, v)


    def subtract(self, v):
        """subtract(Vector3 self, Vector3 v) -> Vector3"""
        return _math_linear.Vector3_subtract(self, v)


    def __add__(self, v):
        """__add__(Vector3 self, Vector3 v) -> Vector3"""
        return _math_linear.Vector3___add__(self, v)


    def __sub__(self, v):
        """__sub__(Vector3 self, Vector3 v) -> Vector3"""
        return _math_linear.Vector3___sub__(self, v)


    def __neg__(self):
        """__neg__(Vector3 self) -> Vector3"""
        return _math_linear.Vector3___neg__(self)


    def __imul__(self, *args):
        """
        __imul__(Vector3 self, Vector3 v) -> Vector3
        __imul__(Vector3 self, double sv) -> Vector3
        """
        return _math_linear.Vector3___imul__(self, *args)


    def __idiv__(self, v):
        """__idiv__(Vector3 self, Vector3 v) -> Vector3"""
        return _math_linear.Vector3___idiv__(self, v)


    def __mul__(self, *args):
        """
        __mul__(Vector3 self, double sv) -> Vector3
        __mul__(Vector3 self, Vector3 v) -> Vector3
        """
        return _math_linear.Vector3___mul__(self, *args)


    def __div__(self, v):
        """__div__(Vector3 self, Vector3 v) -> Vector3"""
        return _math_linear.Vector3___div__(self, v)


    def __getstate__(self):
        return pickle.dumps(self.vals())
    def __setstate__(self, state):
        self.__init__(pickle.loads(state))


    def __getitem__(self, i):
        """__getitem__(Vector3 self, long i) -> double"""
        return _math_linear.Vector3___getitem__(self, i)


    def __setitem__(self, i, val):
        """__setitem__(Vector3 self, long i, double val)"""
        return _math_linear.Vector3___setitem__(self, i, val)


    def __str__(self):
        """__str__(Vector3 self) -> std::string"""
        return _math_linear.Vector3___str__(self)


    def __deepcopy__(self, memo):
        """__deepcopy__(Vector3 self, PyObject * memo) -> Vector3"""
        return _math_linear.Vector3___deepcopy__(self, memo)


    def vals(self):
        """vals(Vector3 self) -> std_vector_double"""
        return _math_linear.Vector3_vals(self)

Vector3_swigregister = _math_linear.Vector3_swigregister
Vector3_swigregister(Vector3)


def cross(*args):
    """
    cross(Vector3 u, Vector3 v) -> Vector3
    cross(VectorDouble u, VectorDouble v) -> VectorDouble
    """
    return _math_linear.cross(*args)
class VectorDouble(_object):
    """Proxy of C++ math::linear::Vector<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorDouble, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorDouble, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math::linear::Vector<(double)> self) -> VectorDouble
        __init__(math::linear::Vector<(double)> self, size_t sz, double sv=0.0) -> VectorDouble
        __init__(math::linear::Vector<(double)> self, size_t sz) -> VectorDouble
        __init__(math::linear::Vector<(double)> self, size_t sz, double const * raw) -> VectorDouble
        __init__(math::linear::Vector<(double)> self, VectorDouble v) -> VectorDouble
        __init__(math::linear::Vector<(double)> self, std_vector_double v) -> VectorDouble
        __init__(math::linear::Vector<(double)> self, MatrixDouble mx) -> VectorDouble
        """
        this = _math_linear.new_VectorDouble(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _math_linear.delete_VectorDouble
    __del__ = lambda self: None

    def size(self):
        """size(VectorDouble self) -> size_t"""
        return _math_linear.VectorDouble_size(self)


    def matrix(self, *args):
        """
        matrix(VectorDouble self) -> MatrixDouble
        matrix(VectorDouble self) -> MatrixDouble
        """
        return _math_linear.VectorDouble_matrix(self, *args)


    def get(self):
        """get(VectorDouble self) -> double const *"""
        return _math_linear.VectorDouble_get(self)


    def dot(self, vec_):
        """dot(VectorDouble self, VectorDouble vec_) -> double"""
        return _math_linear.VectorDouble_dot(self, vec_)


    def angle(self, v):
        """angle(VectorDouble self, VectorDouble v) -> double"""
        return _math_linear.VectorDouble_angle(self, v)


    def normSq(self):
        """normSq(VectorDouble self) -> double"""
        return _math_linear.VectorDouble_normSq(self)


    def norm(self):
        """norm(VectorDouble self) -> double"""
        return _math_linear.VectorDouble_norm(self)


    def normalize(self):
        """normalize(VectorDouble self)"""
        return _math_linear.VectorDouble_normalize(self)


    def scale(self, scalar):
        """scale(VectorDouble self, double scalar)"""
        return _math_linear.VectorDouble_scale(self, scalar)


    def unit(self):
        """unit(VectorDouble self) -> VectorDouble"""
        return _math_linear.VectorDouble_unit(self)


    def __iadd__(self, v):
        """__iadd__(VectorDouble self, VectorDouble v) -> VectorDouble"""
        return _math_linear.VectorDouble___iadd__(self, v)


    def __isub__(self, v):
        """__isub__(VectorDouble self, VectorDouble v) -> VectorDouble"""
        return _math_linear.VectorDouble___isub__(self, v)


    def add(self, v):
        """add(VectorDouble self, VectorDouble v) -> VectorDouble"""
        return _math_linear.VectorDouble_add(self, v)


    def subtract(self, v):
        """subtract(VectorDouble self, VectorDouble v) -> VectorDouble"""
        return _math_linear.VectorDouble_subtract(self, v)


    def __add__(self, v):
        """__add__(VectorDouble self, VectorDouble v) -> VectorDouble"""
        return _math_linear.VectorDouble___add__(self, v)


    def __sub__(self, v):
        """__sub__(VectorDouble self, VectorDouble v) -> VectorDouble"""
        return _math_linear.VectorDouble___sub__(self, v)


    def __neg__(self):
        """__neg__(VectorDouble self) -> VectorDouble"""
        return _math_linear.VectorDouble___neg__(self)


    def __imul__(self, *args):
        """
        __imul__(VectorDouble self, VectorDouble v) -> VectorDouble
        __imul__(VectorDouble self, double sv) -> VectorDouble
        """
        return _math_linear.VectorDouble___imul__(self, *args)


    def __idiv__(self, v):
        """__idiv__(VectorDouble self, VectorDouble v) -> VectorDouble"""
        return _math_linear.VectorDouble___idiv__(self, v)


    def __mul__(self, *args):
        """
        __mul__(VectorDouble self, double sv) -> VectorDouble
        __mul__(VectorDouble self, VectorDouble v) -> VectorDouble
        """
        return _math_linear.VectorDouble___mul__(self, *args)


    def __div__(self, v):
        """__div__(VectorDouble self, VectorDouble v) -> VectorDouble"""
        return _math_linear.VectorDouble___div__(self, v)


    def __getitem__(self, i):
        """__getitem__(VectorDouble self, long i) -> double"""
        return _math_linear.VectorDouble___getitem__(self, i)


    def __setitem__(self, i, val):
        """__setitem__(VectorDouble self, long i, double val)"""
        return _math_linear.VectorDouble___setitem__(self, i, val)


    def __str__(self):
        """__str__(VectorDouble self) -> std::string"""
        return _math_linear.VectorDouble___str__(self)


    def vals(self):
        """vals(VectorDouble self) -> std_vector_double"""
        return _math_linear.VectorDouble_vals(self)

VectorDouble_swigregister = _math_linear.VectorDouble_swigregister
VectorDouble_swigregister(VectorDouble)

class MatrixDouble(_object):
    """Proxy of C++ math::linear::Matrix2D<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MatrixDouble, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MatrixDouble, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math::linear::Matrix2D<(double)> self) -> MatrixDouble
        __init__(math::linear::Matrix2D<(double)> self, size_t M, size_t N, double cv=0) -> MatrixDouble
        __init__(math::linear::Matrix2D<(double)> self, size_t M, size_t N) -> MatrixDouble
        __init__(math::linear::Matrix2D<(double)> self, size_t M, size_t N, double const * raw) -> MatrixDouble
        __init__(math::linear::Matrix2D<(double)> self, size_t M, size_t N, std_vector_double raw) -> MatrixDouble
        __init__(math::linear::Matrix2D<(double)> self, MatrixDouble mx) -> MatrixDouble
        __init__(math::linear::Matrix2D<(double)> self, size_t M, size_t N, double * raw, bool adopt) -> MatrixDouble
        """
        this = _math_linear.new_MatrixDouble(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _math_linear.delete_MatrixDouble
    __del__ = lambda self: None

    def __call__(self, *args):
        """
        __call__(MatrixDouble self, size_t i, size_t j) -> double
        __call__(MatrixDouble self, size_t i, size_t j) -> double &
        """
        return _math_linear.MatrixDouble___call__(self, *args)


    def row(self, *args):
        """
        row(MatrixDouble self, size_t i) -> double const
        row(MatrixDouble self, size_t i) -> double
        row(MatrixDouble self, size_t i, double const * vec_)
        row(MatrixDouble self, size_t i, std_vector_double vec_)
        """
        return _math_linear.MatrixDouble_row(self, *args)


    def col(self, *args):
        """
        col(MatrixDouble self, size_t j) -> std_vector_double
        col(MatrixDouble self, size_t j, double const * vec_)
        col(MatrixDouble self, size_t j, std_vector_double vec_)
        """
        return _math_linear.MatrixDouble_col(self, *args)


    def rows(self):
        """rows(MatrixDouble self) -> size_t"""
        return _math_linear.MatrixDouble_rows(self)


    def cols(self):
        """cols(MatrixDouble self) -> size_t"""
        return _math_linear.MatrixDouble_cols(self)


    def size(self):
        """size(MatrixDouble self) -> size_t"""
        return _math_linear.MatrixDouble_size(self)


    def get(self):
        """get(MatrixDouble self) -> double const *"""
        return _math_linear.MatrixDouble_get(self)


    def scale(self, scalar):
        """scale(MatrixDouble self, double scalar) -> MatrixDouble"""
        return _math_linear.MatrixDouble_scale(self, scalar)


    def multiply(self, *args):
        """
        multiply(MatrixDouble self, double scalar) -> MatrixDouble
        multiply(MatrixDouble self, MatrixDouble mx) -> MatrixDouble
        multiply(MatrixDouble self, MatrixDouble mx, MatrixDouble out)
        """
        return _math_linear.MatrixDouble_multiply(self, *args)


    def scaleDiagonal(self, mx):
        """scaleDiagonal(MatrixDouble self, MatrixDouble mx) -> MatrixDouble"""
        return _math_linear.MatrixDouble_scaleDiagonal(self, mx)


    def scaleDiagonalRowVector(self, mx):
        """scaleDiagonalRowVector(MatrixDouble self, MatrixDouble mx) -> MatrixDouble"""
        return _math_linear.MatrixDouble_scaleDiagonalRowVector(self, mx)


    def multiplyDiagonal(self, mx):
        """multiplyDiagonal(MatrixDouble self, MatrixDouble mx) -> MatrixDouble"""
        return _math_linear.MatrixDouble_multiplyDiagonal(self, mx)


    def multiplyDiagonalRowVector(self, mx):
        """multiplyDiagonalRowVector(MatrixDouble self, MatrixDouble mx) -> MatrixDouble"""
        return _math_linear.MatrixDouble_multiplyDiagonalRowVector(self, mx)


    def __iadd__(self, mx):
        """__iadd__(MatrixDouble self, MatrixDouble mx) -> MatrixDouble"""
        return _math_linear.MatrixDouble___iadd__(self, mx)


    def __isub__(self, mx):
        """__isub__(MatrixDouble self, MatrixDouble mx) -> MatrixDouble"""
        return _math_linear.MatrixDouble___isub__(self, mx)


    def add(self, mx):
        """add(MatrixDouble self, MatrixDouble mx) -> MatrixDouble"""
        return _math_linear.MatrixDouble_add(self, mx)


    def subtract(self, mx):
        """subtract(MatrixDouble self, MatrixDouble mx) -> MatrixDouble"""
        return _math_linear.MatrixDouble_subtract(self, mx)


    def transpose(self):
        """transpose(MatrixDouble self) -> MatrixDouble"""
        return _math_linear.MatrixDouble_transpose(self)


    def decomposeLU(self, pivotsM):
        """decomposeLU(MatrixDouble self, VectorSizeT pivotsM) -> MatrixDouble"""
        return _math_linear.MatrixDouble_decomposeLU(self, pivotsM)


    def permute(self, pivotsM, n=0):
        """
        permute(MatrixDouble self, VectorSizeT pivotsM, size_t n=0) -> MatrixDouble
        permute(MatrixDouble self, VectorSizeT pivotsM) -> MatrixDouble
        """
        return _math_linear.MatrixDouble_permute(self, pivotsM, n)


    def normSq(self):
        """normSq(MatrixDouble self) -> double"""
        return _math_linear.MatrixDouble_normSq(self)


    def norm(self):
        """norm(MatrixDouble self) -> double"""
        return _math_linear.MatrixDouble_norm(self)


    def normalize(self):
        """normalize(MatrixDouble self) -> MatrixDouble"""
        return _math_linear.MatrixDouble_normalize(self)


    def unit(self):
        """unit(MatrixDouble self) -> MatrixDouble"""
        return _math_linear.MatrixDouble_unit(self)


    def __add__(self, mx):
        """__add__(MatrixDouble self, MatrixDouble mx) -> MatrixDouble"""
        return _math_linear.MatrixDouble___add__(self, mx)


    def __sub__(self, mx):
        """__sub__(MatrixDouble self, MatrixDouble mx) -> MatrixDouble"""
        return _math_linear.MatrixDouble___sub__(self, mx)


    def __div__(self, scalar):
        """__div__(MatrixDouble self, double scalar) -> MatrixDouble"""
        return _math_linear.MatrixDouble___div__(self, scalar)


    def __mul__(self, *args):
        """
        __mul__(MatrixDouble self, double scalar) -> MatrixDouble
        __mul__(MatrixDouble self, MatrixDouble mx) -> MatrixDouble
        """
        return _math_linear.MatrixDouble___mul__(self, *args)


    def __neg__(self):
        """__neg__(MatrixDouble self) -> MatrixDouble"""
        return _math_linear.MatrixDouble___neg__(self)


    def __getitem__(self, inObj):
        """__getitem__(MatrixDouble self, PyObject * inObj) -> double"""
        return _math_linear.MatrixDouble___getitem__(self, inObj)


    def __setitem__(self, inObj, val):
        """__setitem__(MatrixDouble self, PyObject * inObj, double val)"""
        return _math_linear.MatrixDouble___setitem__(self, inObj, val)


    def __str__(self):
        """__str__(MatrixDouble self) -> std::string"""
        return _math_linear.MatrixDouble___str__(self)


    def vals(self):
        """vals(MatrixDouble self) -> std_vector_vector_double"""
        return _math_linear.MatrixDouble_vals(self)

MatrixDouble_swigregister = _math_linear.MatrixDouble_swigregister
MatrixDouble_swigregister(MatrixDouble)

# This file is compatible with both classic and new-style classes.


